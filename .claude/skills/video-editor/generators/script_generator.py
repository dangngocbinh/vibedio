"""Generate complete Python scripts from editing operations."""

import re
from typing import List, Tuple
from pathlib import Path
from .command_parser import Operation
from .template_engine import TemplateEngine


class CodeFormatter:
    """Format generated Python code."""

    @staticmethod
    def format_code(code: str) -> str:
        """
        Format Python code (remove excessive blank lines, indent).

        Args:
            code: Raw Python code

        Returns:
            Formatted code
        """
        lines = code.split('\n')
        formatted = []
        blank_count = 0

        for line in lines:
            if line.strip() == '':
                blank_count += 1
                if blank_count <= 2:  # Max 2 consecutive blank lines
                    formatted.append('')
            else:
                blank_count = 0
                formatted.append(line)

        return '\n'.join(formatted)

    @staticmethod
    def indent_code(code: str, indent: int = 4) -> str:
        """Indent code block."""
        indent_str = ' ' * indent
        return '\n'.join(
            indent_str + line if line.strip() else line
            for line in code.split('\n')
        )


class ScriptGenerator:
    """Generate complete Python scripts from operations."""

    def __init__(self):
        """Initialize script generator."""
        self.template_engine = TemplateEngine()
        self.formatter = CodeFormatter()

    def generate(
        self,
        operations: List[Operation],
        project_file_path: str,
        output_mode: str = 'standalone'
    ) -> str:
        """
        Generate complete Python script.

        Args:
            operations: List of Operation objects
            project_file_path: Path to project.otio file
            output_mode: 'standalone' or 'functions'

        Returns:
            Complete Python script as string
        """
        # 1. Generate imports
        imports = self._generate_imports(operations)

        # 2. Generate helper functions
        helper_functions = self.template_engine.get_helper_functions()

        # 3. Generate boilerplate (load/save)
        boilerplate = self._generate_boilerplate(project_file_path)

        # 4. Generate operation code
        operation_code = []
        for op in operations:
            code = self.template_engine.render(op)
            operation_code.append(code)

        # 5. Compose script
        sections = [
            imports,
            '',
            '# ============================================================================',
            '# HELPER FUNCTIONS',
            '# ============================================================================',
            '',
            helper_functions,
            '',
            '# ============================================================================',
            '# MAIN SCRIPT',
            '# ============================================================================',
            '',
            boilerplate,
            '',
            '\n'.join(operation_code),
            '',
            '# Save timeline',
            'otio.adapters.write_to_file(timeline, project_file)',
            'print("✓ Timeline saved successfully")',
        ]

        script = '\n'.join(sections)
        return self.formatter.format_code(script)

    def _generate_imports(self, operations: List[Operation]) -> str:
        """Generate import statements based on operations used."""
        imports = [
            '#!/usr/bin/env python3',
            '"""',
            'Auto-generated OTIO editing script.',
            'Generated by: video-editor skill - Script Generator',
            '"""',
            '',
            'import opentimelineio as otio',
            'from pathlib import Path',
        ]

        return '\n'.join(imports)

    def _generate_boilerplate(self, project_file_path: str) -> str:
        """Generate boilerplate code to load and save project."""
        return f'''# Load timeline
project_file = "{project_file_path}"
if not Path(project_file).exists():
    print(f"✗ Project file not found: {{project_file}}")
    exit(1)

timeline = otio.adapters.read_from_file(project_file)
print(f"✓ Loaded timeline: {{timeline.name}}")
print(f"  Tracks: {{len(timeline.tracks)}}")
for i, track in enumerate(timeline.tracks):
    print(f"    {{i}}: {{track.name}} ({{len(track)}} items)")
'''

    def validate_script(self, script_code: str) -> Tuple[bool, List[str]]:
        """
        Validate generated Python script.

        Args:
            script_code: Python code as string

        Returns:
            (is_valid, errors)
        """
        errors = []

        # 1. Syntax check
        try:
            compile(script_code, '<generated>', 'exec')
        except SyntaxError as e:
            errors.append(f"Syntax error: {e}")

        # 2. Check for dangerous operations
        dangerous_patterns = [
            r'os\.system',
            r'subprocess\.call',
            r'eval\(',
            r'\bexec\(',
            r'__import__',
        ]

        for pattern in dangerous_patterns:
            if re.search(pattern, script_code):
                errors.append(f"Dangerous operation detected: {pattern}")

        # 3. Check required imports
        if 'import opentimelineio' not in script_code:
            errors.append("Missing import: opentimelineio")

        return (len(errors) == 0, errors)


class WorkflowGenerator:
    """Generate scripts from workflow templates."""

    def __init__(self):
        """Initialize workflow generator."""
        self.script_generator = ScriptGenerator()
        self.template_engine = TemplateEngine()

    def generate_intro_outro(
        self,
        project_file_path: str,
        intro_file: str,
        outro_file: str,
        intro_duration: float = 3.0,
        outro_duration: float = 3.0,
    ) -> str:
        """
        Generate intro/outro workflow script.

        Args:
            project_file_path: Path to project.otio
            intro_file: Path to intro video file
            outro_file: Path to outro video file
            intro_duration: Duration of intro in seconds
            outro_duration: Duration of outro in seconds

        Returns:
            Complete script
        """
        imports = [
            '#!/usr/bin/env python3',
            '"""Intro/Outro Workflow"""',
            'import opentimelineio as otio',
            'from pathlib import Path',
            '',
        ]

        helper_functions = self.template_engine.get_helper_functions()

        boilerplate = f'''# Load timeline
timeline = otio.adapters.read_from_file("{project_file_path}")
print(f"✓ Loaded timeline: {{timeline.name}}")
'''

        workflow = f'''# ============================================================================
# INTRO/OUTRO WORKFLOW
# ============================================================================
print("Adding intro and outro...")

# 1. Create intro clip
intro = otio.schema.Clip(
    name="Intro",
    media_reference=otio.schema.ExternalReference(target_url="{intro_file}"),
    source_range=otio.opentime.TimeRange(
        start_time=otio.opentime.from_seconds(0),
        duration=otio.opentime.from_seconds({intro_duration})
    )
)

# 2. Create outro clip
outro = otio.schema.Clip(
    name="Outro",
    media_reference=otio.schema.ExternalReference(target_url="{outro_file}"),
    source_range=otio.opentime.TimeRange(
        start_time=otio.opentime.from_seconds(0),
        duration=otio.opentime.from_seconds({outro_duration})
    )
)

# 3. Insert intro at beginning of main video track
if len(timeline.tracks) > 0:
    main_track = timeline.tracks[0]
    main_track.insert(0, intro)
    print("✓ Added intro")

    # 4. Append outro at end
    main_track.append(outro)
    print("✓ Added outro")

    # 5. Extend other tracks with gaps to maintain sync
    intro_duration_val = intro.duration().to_seconds()
    outro_duration_val = outro.duration().to_seconds()

    for i, track in enumerate(timeline.tracks):
        if i == 0:  # Skip main track
            continue

        # Add gap at beginning
        gap_start = otio.schema.Gap(
            duration=otio.opentime.from_seconds(intro_duration_val)
        )
        track.insert(0, gap_start)

        # Add gap at end
        gap_end = otio.schema.Gap(
            duration=otio.opentime.from_seconds(outro_duration_val)
        )
        track.append(gap_end)

    print(f"✓ Extended {{len(timeline.tracks) - 1}} tracks with gaps")
    print("✓ Intro/outro workflow complete")
else:
    print("✗ Timeline has no tracks")
'''

        save = '''# Save timeline
otio.adapters.write_to_file(timeline, "{project_file_path}")
print("✓ Timeline saved successfully")
'''.format(project_file_path=project_file_path)

        script = '\n'.join(imports) + '\n\n' + helper_functions + '\n\n' + boilerplate + '\n' + workflow + '\n' + save

        return CodeFormatter.format_code(script)

    def generate_watermark(
        self,
        project_file_path: str,
        watermark_file: str,
        position: str = 'bottom-right',
        duration: float = 30.0,
    ) -> str:
        """
        Generate watermark overlay workflow script.

        Args:
            project_file_path: Path to project.otio
            watermark_file: Path to watermark image/video
            position: Position ('top-left', 'bottom-right', etc.)
            duration: Duration to show watermark in seconds

        Returns:
            Complete script
        """
        imports = [
            '#!/usr/bin/env python3',
            '"""Watermark Overlay Workflow"""',
            'import opentimelineio as otio',
            'from pathlib import Path',
            '',
        ]

        helper_functions = self.template_engine.get_helper_functions()

        boilerplate = f'''# Load timeline
timeline = otio.adapters.read_from_file("{project_file_path}")
print(f"✓ Loaded timeline: {{timeline.name}}")
'''

        workflow = f'''# ============================================================================
# WATERMARK OVERLAY WORKFLOW
# ============================================================================
print("Adding watermark overlay...")

# Create watermark clip
watermark = otio.schema.Clip(
    name="Watermark ({position})",
    media_reference=otio.schema.ExternalReference(target_url="{watermark_file}"),
    source_range=otio.opentime.TimeRange(
        start_time=otio.opentime.from_seconds(0),
        duration=otio.opentime.from_seconds({duration})
    )
)

# Add to overlay/graphics track (create if needed)
overlay_track = None
for track in timeline.tracks:
    if 'overlay' in track.name.lower() or 'graphics' in track.name.lower():
        overlay_track = track
        break

if not overlay_track:
    overlay_track = otio.schema.Track(name="Overlay", kind=otio.schema.TrackKind.Video)
    timeline.tracks.append(overlay_track)
    print("✓ Created overlay track")

overlay_track.append(watermark)
print(f"✓ Added watermark at {{position}}")
print("✓ Watermark workflow complete")
'''

        save = '''# Save timeline
otio.adapters.write_to_file(timeline, "{project_file_path}")
print("✓ Timeline saved successfully")
'''.format(project_file_path=project_file_path)

        script = '\n'.join(imports) + '\n\n' + helper_functions + '\n\n' + boilerplate + '\n' + workflow + '\n' + save

        return CodeFormatter.format_code(script)

    def generate_ripple_edit(
        self,
        project_file_path: str,
        clip_index: int,
        track_index: int = 0,
    ) -> str:
        """
        Generate ripple delete workflow script.

        Args:
            project_file_path: Path to project.otio
            clip_index: Index of clip to remove
            track_index: Track index

        Returns:
            Complete script
        """
        imports = [
            '#!/usr/bin/env python3',
            '"""Ripple Edit Workflow"""',
            'import opentimelineio as otio',
            'from pathlib import Path',
            '',
        ]

        helper_functions = self.template_engine.get_helper_functions()

        boilerplate = f'''# Load timeline
timeline = otio.adapters.read_from_file("{project_file_path}")
print(f"✓ Loaded timeline: {{timeline.name}}")
'''

        workflow = f'''# ============================================================================
# RIPPLE EDIT WORKFLOW
# ============================================================================
print("Performing ripple delete...")

track = timeline.tracks[{track_index}]

if {clip_index} < len(track):
    # Get duration of clip to be removed
    removed_clip = track[{clip_index}]
    removed_duration = removed_clip.duration() if hasattr(removed_clip, 'duration') else None
    removed_name = removed_clip.name if hasattr(removed_clip, 'name') else 'Unknown'

    # Remove the clip
    track.pop({clip_index})
    print(f"✓ Removed clip: {{removed_name}}")

    # Ripple: All clips after {clip_index} shift backward
    # (Timeline automatically handles this with OTIO)
    print(f"✓ Ripple edit complete - {{len(track)}} items remaining in track")
else:
    print(f"✗ Clip index {clip_index} out of range (track has {{len(track)}} items)")
'''

        save = '''# Save timeline
otio.adapters.write_to_file(timeline, "{project_file_path}")
print("✓ Timeline saved successfully")
'''.format(project_file_path=project_file_path)

        script = '\n'.join(imports) + '\n\n' + helper_functions + '\n\n' + boilerplate + '\n' + workflow + '\n' + save

        return CodeFormatter.format_code(script)
